import { IContents } from "@models/definitions/content/types/IContents";
import { IAssignmentWriter } from "@writers/statements/assignmentWriter/types/IAssignmentWriter";
import { IBreakWriter } from "@writers/statements/breakWriter/types/IBreakWriter";
import { IDoWhileWriter } from "@writers/statements/doWhileWriter/types/IDoWhileWriter";
import { IEventCallWriter } from "@writers/statements/eventCallWriter/types/IEventCallWriter";
import { IForWriter } from "@writers/statements/forWriter/types/IForWriter";
import { IIfWriter } from "@writers/statements/ifWriter/types/IIfWriter";
import { IMethodCallWriter } from "@writers/statements/methodCallWriter/types/IMethodCallWriter";
import { IRequireWriter } from "@writers/statements/requireWriter/types/IRequireWriter";
import { IRevertWriter } from "@writers/statements/revertWriter/types/IRevertWriter";
import { IWhileWriter } from "@writers/statements/whileWriter/types/IWhileWriter";
import { IVariableWriter } from "@writers/statements/variableWriter/types/IVariableWriter";
import { IContentWriter } from "../types/IContentWriter";
import { IReturnWriter } from "@writers/statements/returnWriter/types/IReturnWriter";
import { IAssert } from "@models/statements/assert/types/IAssert";
import { ITryWriter } from "@writers/statements/tryWriter/types/ITryWriter";
import { ICatchWriter } from "@writers/statements/catchWriter/types/ICatchWriter";
import { IContinueWriter } from "@writers/statements/continueWriter/types/IContinueWriter";
import { IExpressionWriter } from "@writers/statements/expressionWriter/types/IExpressionWriter";
import { IMappingWriter } from "@writers/statements/mappingWriter/types/IMappingWriter";
import { INewContractWriter } from "@writers/statements/newContractWriter/types/INewContractWriter";
declare class ContentWriter implements IContentWriter {
    private assertWriter;
    private assignmentWriter;
    private ifWriter;
    private forWriter;
    private eventCallWriter;
    private variableWriter;
    private methodCallWriter;
    private requireWriter;
    private revertWriter;
    private breakWriter;
    private whileWriter;
    private doWhileWriter;
    private returnWriter;
    private tryWriter;
    private catchWriter;
    private continueWriter;
    private expressionWriter;
    private mappingWriter;
    private newContractWriter;
    constructor(assertWriter: IAssert, assignmentWriter: IAssignmentWriter, ifWriter: IIfWriter, forWriter: IForWriter, eventCallWriter: IEventCallWriter, variableWriter: IVariableWriter, methodCallWriter: IMethodCallWriter, requireWriter: IRequireWriter, revertWriter: IRevertWriter, breakWriter: IBreakWriter, whileWriter: IWhileWriter, doWhileWriter: IDoWhileWriter, returnWriter: IReturnWriter, tryWriter: ITryWriter, catchWriter: ICatchWriter, continueWriter: IContinueWriter, expressionWriter: IExpressionWriter, mappingWriter: IMappingWriter, newContractWriter: INewContractWriter);
    statements: {
        assert: IAssert;
        assignment: IAssignmentWriter;
        if: IIfWriter;
        for: IForWriter;
        event_call: IEventCallWriter;
        variable: IVariableWriter;
        method_call: IMethodCallWriter;
        require: IRequireWriter;
        revert: IRevertWriter;
        break: IBreakWriter;
        while: IWhileWriter;
        doWhile: IDoWhileWriter;
        return: IReturnWriter;
        try: ITryWriter;
        catch: ICatchWriter;
        continue: IContinueWriter;
        expression: IExpressionWriter;
        mapping: IMappingWriter;
        newContract: INewContractWriter;
    };
    controls: string[];
    write(content: Array<IContents>): string;
}
export default ContentWriter;
